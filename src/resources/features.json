{"language": [{"name": "C++", "type": "Language", "summary": "A powerful but complicated language. Designed to be fast but enable abstraction.", "keyFeatures": ["Manual memory management", "Weak types, unchecked at runtime", "Compiled to assembly", "Object-oriented but supports first class functions"], "benefits": ["Very **expressive** - can write code with almost any paradigm (object-oriented, functional, etc.)", "One of the **fastest** and **most memory-efficient** languages - as fast as C", "Used by a lot of **companies** (TODO statistic)"], "drawbacks": ["Because it\u2019s so flexible, **very hard** to write clear code - requires experience and a strict style guide", "**Verbose**", "**Confusing compiler errors**, especially with templates", "**Unsafe** - memory corruption errors are hard to find and can be exploited", "**Weak package management** - hard to compile and add libraries"], "useCases": ["Embedded systems", "Bytecode interpreters", "Other programs which need to be fast and memory-efficient"], "background": "Released in ..., but is constantly extended with new features even today. The C language extended with classes and powerful templates.", "examples": []}, {"name": "JavaScript", "summary": "Practically the only language to put dynamic content (e.g. animations) on websites. Also can create desktop apps via node.js.", "keyFeatures": ["Garbage collected", "No types at compile-time, minimal at runtime", "Interpreted", "\u201cAd-hoc\u201d object-oriented but supports first class functions", "*Many different languages (PureScript, Scala.js, TypeScript) which \u201ctranspile\u201d into it* - often you can use these languages instead where you would need JavaScript*"], "benefits": ["**Expressive** - even supports extending builtin types", "**Widely supported** - online, so computers, phones, and even consoles use it. Can also create [desktop] and [mobile] applications", "**Many resources** - libraries and knowledge", "**Integrated namespaces and package management** (npm) when using node.js"], "drawbacks": ["**Hard to find bugs** - almost no runtime errors (and definitely no compile-time errors)", "**Strange semantics** - causes weird edge cases, e.g. `{} + [] == ` but `[] + {} == `", "**Slow** because it\u2019s interpreted", "**Ad-hoc namespaces and no package management** when not using node.js"], "useCases": ["Websites", "Cross-platform applications", "Extensions for applications developed in JavaScript (e.g. Visual Studio Code)"], "background": "Originally designed to be a Scheme-like language, syntax was changed and name became JavaScript shortly before release to increase popularity.", "examples": []}, {"name": "Java", "summary": "Currently the most widely-used language, general-purpose", "keyFeatures": ["Object-oriented, minimal lambda support", "Weak types, checked at runtime", "Compiled to JVM bytecode", "Garbage collected"], "benefits": ["**Widely used** - likely to find a job", "**Encourages good design** for beginners, e.g. all code must be implemented in classes, every class", "**Safe** - Runtime type checking and garbage collection makes most errors easy to find"], "drawbacks": ["**Verbose**", "**Strict standards** - e.g. all code must be implemented in classes", "**Hard to implement** functional programming, especially in earlier versions", "**Slow**"], "useCases": ["Teaching / learning to code", "General programs", "Embedded systems which don\u2019t need to be particularly fast"], "background": "Developed by Oracle in ... for embedded systems.", "examples": []}, {"name": "Haskell", "summary": "The most popular purely functional programming language, much different than *traditional* languages", "keyFeatures": ["**Lazy** - doesn\u2019t evaluate expressions in sequence, waits until they\u2019re needed", "Purely functional", "Strong types, higher kinds, minimal dependent types (Hindley-Milner)", "Compiled to assembly, heavily optimized", "Garbage collected"], "benefits": ["**Concise:** Haskell often requires much less code to perform the same actions as other languages", "**Fast**, especially for a functional language, because of optimizations and lazy semantics", "**Safe:** because of strong type checking, Haskell code often takes much less time to debug *after compiling*", "**Teaches** unique programming concepts"], "drawbacks": ["**Hard to represent state:** programs which need a sequence of actions, like video games or simulations, require \u201cmonads\u201d and confusing syntax, and they can actually be more verbose than in other languages. Most Haskell programs are simple-command line - there are relatively few programs with GUIs, and even fewer video games", "**Steep learning curve** because it\u2019s so much different than other languages", "**Hard to debug:** Lazy semantics make evaluation very confusing, and because there isn\u2019t any state, it\u2019s hard to print expressions", "Not used by many **companies**, hard to get a Haskell job"], "useCases": ["Teaching / learning to code", "Compilers", "Calculators", "Programs which \u201cread an input and produce an output\u201d"], "background": "...", "examples": []}, {"name": "Scheme", "summary": "Incredibly simple language used in research and education but rarely in production", "keyFeatures": ["**Extensible** - can change its semantics via macros", "Functional with state, supports \u201cbare-bones\u201d object-oriented programming", "Weak types, minimally checked at runtime (unless you provide checks)", "Garbage collected"], "benefits": ["**Simple:** Very easy to understand and write an interpreter for", "**Extensible:** Macros allow you to almost completely modify the semantics"], "drawbacks": ["Most dialects **not usable in practice** - they have limited built-in support, some can\u2019t even do I/O or display a GUI", "**Slow** - typically it\u2019s interpreted, but even when compiled, slower than languages like C"], "useCases": ["Teaching / learning"], "background": "Developed in ...", "examples": []}], "paradigm": [{"name": "Object-Oriented", "summary": "Represents all concepts as \u201cobjects\u201d, and the actions they perform as \u201cmethods\u201d. These objects are typically mutable", "keyFeatures": [], "benefits": ["Most people understand this paradigm", "**Intuitive:** teaches and represents structure very well, humans think of concepts and actions similarly to \u201cobjects\u201d and \u201cmethods\u201d"], "drawbacks": ["**Verbose** - objects are often very large, and an object often requires more code than an equivalent structure", "Hard to **keep track of state** - because objects are mutable, they can change at unexpected times and break assumptions, leading to bugs", "Not all functions \u201cbelong\u201d to an object. For example, `add(a, b)` is much clearer than `a.add(b)` or `b.add(a)`"], "useCases": ["Programs which model the real world (e.g. video games)"], "background": "TODO ...", "examples": []}], "library": [], "ide": []}
