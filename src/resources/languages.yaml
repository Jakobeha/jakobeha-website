general:
- name: General
  icon: folder-src
  summary: '"All around", not specialized for one type of project, instead designed for any project'
  keyFeatures:
  - '**Multi-paradigm:** most are primarily **object-oriented**, but include functional concepts like lambdas, and are flexible in general'
  - 'Almost always **compiled**'
  - 'Usually **garbage collected**, designed for ease-of-use over speed'
  benefits:
  - "Usually **flexible:** support many code paradigms and styles"
  drawbacks:
  - '**Harder to setup** than scripting languages, since they must be compiled'
  useCases:
  - "Large or medium-size programs which don't need to be especially fast"
  - 'Indie games, side projects, etc.'
- name: Java
  icon: java
  summary: Currently the most popular, widely-used language. [Source](https://sdtimes.com/softwaredev/report-the-top-three-programming-languages-of-2018-are-java-javascript-and-python/)
  keyFeatures:
  - 'Explicitly **object-oriented**, has very strict rules'
  - '**Weak types**, checked at runtime'
  - '**Compiled** to JVM bytecode, which runs on many different machines'
  - '**Garbage collected**'
  benefits:
  - '**Most popular** (as of 2019): lots of online resources, very likely to find a job. [Statistic](https://www.tiobe.com/tiobe-index/java/)'
  - '**Encourages good design** for beginners, because it has strict rules. For example, all code must be organized into classes, each class must be in its own file'
  - '**Easy to setup and debug:** well-supported by multiple IDEs, including [Eclipse](https://www.eclipse.org/) and [IntelliJ IDEA](https://www.jetbrains.com/idea/)'
  drawbacks:
  - '**Verbose**'
  - "**Doesn't support other paradigms well.** For example, Java has \"lambdas\", but they're actually syntax sugar for objects. [Source](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)"
  - "Sometimes require you to write code in unintuitive ways. For example, even a simple \"Hello World\" program requires a class."
  - '**Slow:** runtime type checking and JVM make the language slower'
  useCases:
  - "Large or medium-size programs which don't need to be especially fast (same as other general languages)"
  - 'Teaching / learning to code'
  - 'Cross-platform programs or embedded systems'
  history: Developed by Oracle in 1995 for websites. Ironically, now used by many other systems but not common in websites anymore. [Source](https://mathbits.com/MathBits/Java/Introduction/BriefHistory.htm)
  example: |
    ```java
    interface Shape {
      int getArea();
    }

    class Square implements Shape {
      private int width;
      public Square(int w) { width = w; }
      public int getArea() { return width * width; }
    }

    class Main {
      public static void main(String[] args) {
        System.out.print("Square width = ");
        Scanner input = new Scanner(System.in);
        Square square = new Square(input.nextInt());
        System.out.println("Square area = " + square.getArea());
      }
    }
    ```
  tutorials:
  - https://www.w3schools.com/java/java_intro.asp
  - https://www.youtube.com/watch?v=grEKMHGYyns
- name: Scala
  icon: scala
  summary: Designed to improve Java by being more concise and better supporting functional programming
  keyFeatures:
  - "Explicitly supports both **object-oriented and functional** programming"
  - "**Strong types** (checked at compile-time), casts checked at runtime"
  - "**Compiled** to JVM bytecode"
  - "**Garbage collected**"
  benefits:
  - '**Flexible:** almost the entire syntax can be rewritten (see ["Baysic" - BASIC code in Scala](https://www.scala-lang.org/old/node/1403))'
  - "**Safe:** because of strong types, most bugs are spotted when code is compiled, not run"
  - "**Compatible with Java:** Scala code can use Java libraries, and vice versa"
  - "**Easy to setup and debug:** supported by [IntelliJ IDEA](https://www.jetbrains.com/idea/) and [Eclipse](http://scala-ide.org/)"
  drawbacks:
  - "**Steep learning curve:** not as unique as Haskell, but many ([[1]](http://baddotrobot.com/blog/2014/11/25/scala-learning-curve/), [[2]](https://www.toptal.com/scala/why-should-i-learn-scala), [[3]](http://julien.gunnm.org/scala/programming/2018/06/12/how-to-learn-scala-in-2018/)), believe it's harder to learn than Java"
  - "**Confusing compiler errors:** many libraries use \"implicits\", which are usually inferred by the compiler, but when they can’t be inferred, they're tough to debug"
  useCases:
  - "When you don't want to use Java but want / need Java libraries"
  - 'Web servers (see [Play Framework](https://www.playframework.com/)) and clients (see [Scala.js](https://www.scala-js.org/))'
  - 'Very large applications'
  example: |
    ```scala
    trait Shape {
      def getArea(): Int
    }

    case class Square(width: Int) extends Shape {
      override def getArea(): Int = width * width
    }

    object Main {
      def main(args: Array[String]): Unit = {
        print("Square width = ")
        val square = Square(scala.io.StdIn.readInt())
        println(s"Square area = ${square.getArea()}")
      }
    }
    ```
  tutorials:
  - https://docs.scala-lang.org/tutorials/tour/tour-of-scala.html.html
  - https://www.scala-exercises.org/std_lib/asserts
  - https://www.youtube.com/watch?v=LQVDJtfpQU0
- name: Swift
  icon: swift
  summary: Developed by Apple for writing programs for macOS, iOS, and other Apple operating systems. [Source](https://developer.apple.com/swift/)
  keyFeatures:
  - '**Object-oriented and functional**. [Source](https://skookum.com/blog/swift-blurs-the-lines-of-programming-paradigms)'
  - '**Strong types**, casts checked at runtime'
  - '**Compiled** to assembly'
  - '**Requires some explicit memory management:** uses [automatic reference counting](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)'
  benefits:
  - '**Concise:** has a lot of syntactic sugar, and often uses "structures" which are like objects but require less code'
  - '**Efficient:** designed for perfomance, and because of automatic reference counting, Swift is typically faster than other general-purpose languages like Java, but typically not as fast as C'
  - '**Well-supported:** easy to setup and debug with [Xcode](https://developer.apple.com/xcode/), many online tutorials'
  drawbacks:
  - '**Not supported on many non-macOS platforms:** although there is minimal Linux support, many libraries and other features are missing'
  - 'Sometimes it slows down and crashes the Xcode IDE, because of its complicated syntax'
  useCases:
  - 'iOS, watchOS, or Mac-specific apps'
  history: Developed in 2010 and released in 2014, intended to replace Objective-C and thus make it easier to program Mac and iOS applications. [Source](https://www.cleverism.com/skills-and-tools/swift/)
  example: |
    ```swift
    import Foundation

    protocol Shape {
      func getArea() -> Int
    }

    struct Square: Shape {
      let width: Int
      func getArea() -> Int { return width * width; }
    }

    print("Square width = ");
    let square = Square(width: Int(readLine()!));
    println("Square area = \(square.getArea())");
    ```
  tutorials:
  - https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-ID1
  - https://www.youtube.com/watch?v=Ulp1Kimblg0
- name: TypeScript
  icon: typescript
  summary: JavaScript wrapper with optional type annotations. [Source](https://www.typescriptlang.org/)
  keyFeatures:
  - "**Object-oriented and functional:** supports objects, but also functional concepts like records, variants and lambdas"
  - "**\"Strong or weak\" type system:** the more type annotations you add, the more the compiler will check that they’re valid"
  - "**Interpreted:** transpiled (converted) into JavaScript"
  - "**Garbage collected**"
  benefits:
  - "**Flexible types:** supports [intersection types, union types](https://codepunk.io/typescript-intersection-and-union-types/), [\"duck typing\"](https://www.typescriptlang.org/docs/handbook/interfaces.html) *in theory*. [Learn more about supported types](https://github.com/blakeembrey/a-brief-history-of-types-with-typescript)"
  - "**JavaScript wrapper:** transpiled to JavaScript, and has practically all JavaScript’s benefits, including **wide support**, **extensibility**, and **resources**. It even supports [node.js](https://nodejs.org/)"
  drawbacks:
  - "**Must be compiled,** unlike JavaScript, and it also requires more tools to setup"
  - "**Type system isn't always checked,** so you can still end up getting unexpected type errors, particularly when you interact with untyped code"
  useCases:
  - "JavaScript with more type safety"
  history: Developed in 2012, to write large programs in JavaScript. [Source](https://www.dotnetcurry.com/typescript/1287/typescript-quick-start-tutorial)
  example: |
    ```ts
    interface Square {
      width: number;
    }

    function promptWidth(): number {
      return parseInt(prompt("Square width = ..."));
    }

    function printArea({ width }: Square) {
      console.log("Square area = " + width * width);
    }

    const square: Square = { width: promptWidth() };
    printArea(square); // Area = 2500
    ```
  tutorials:
  - https://code.visualstudio.com/docs/typescript/typescript-tutorial
  - https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html
  - https://www.youtube.com/watch?v=WBPrJSw7yQA
scripting:
- name: Scripting
  icon: folder-sass
  summary: "Designed to write working code fast, even if it isn't maintainable long-term"
  keyFeatures:
  - 'Usually **weak types** (explicit type annotations would require you to write more code)'
  - 'Usually **interpreted**'
  - 'Always **garbage collected** or have some other automatic memory management'
  benefits:
  - 'Usually **easy and quick** to setup'
  - 'Code doesn’t need to be recompiled, saving time during development'
  drawbacks:
  - 'Interpreted programs run slower than compiled programs'
  useCases:
  - 'Small programs'
  - 'Prototypes for larger programs'
  - 'Programming exercises'
- name: Bash
  icon: console
  summary: Very small language and interpreter used by the command line
  keyFeatures:
  - "**Procedural:** no support for objects. [Source](https://stackoverflow.com/questions/36771080/creating-classes-and-objects-using-bash-scripting/36771175)"
  - "**Untyped:** every variable is a string. [Source](https://www.tldp.org/LDP/abs/html/untyped.html)"
  - "**Interpreted** by the command line"
  - "Some versions have garbage collection, others have no memory management. [Source](https://stackoverflow.com/questions/41537802/how-does-bash-manage-its-memory)"
  benefits:
  - "**Easy to run:** simply open \"Terminal\" on macOS or Linux, and start typing. All command-line statements are actually Bash code"
  - "**Extensible:** Any command-line command is run simply by typing its path. Get new commands via tools like [HomeBrew](https://brew.sh/)"
  - "**Portable:** Supported by nearly all Unix operating systems, including Mac and Linux. Windows has a similar language called [PowerShell](https://docs.microsoft.com/en-us/powershell/scripting/overview)"
  drawbacks:
  - "**Practically no abstraction:** it's almost impossible to write large programs"
  - "**Hard to debug:** errors don't terminate shell scripts, and some statements produce unexpected results. See [Bash Pitfalls](https://mywiki.wooledge.org/BashPitfalls)"
  useCases:
  - "Automate very small tasks, such as \"for each image in a folder, read the image, resize it, then save it\""
  history: Bash stands for "Bourne-Again SHell", and is a type of "shell". Shells are very old - the first was created in 1971. [Source](https://www.ibm.com/developerworks/library/l-linux-shells/index.html)
  example: |
    ```bash
    interface Square {
      width: number;
    }

    echo "Square width = "
    read WIDTH
    AREA=$(( WIDTH * WIDTH ))
    echo "Square area = $AREA"
    ```
  tutorials:
  - http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html
  - https://youtube.com/watch?v=QGvvJO5UIs4
- name: JavaScript
  icon: javascript
  summary: The "programming language of the web", used to add dynamic content to websites. [Source](https://www.w3schools.com/js/), [More info](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
  keyFeatures:
  - '**Multi-paradigm:** "Ad-hoc" object-oriented and functional support'
  - '**Weak types**, rarely checked at runtime. There are only a few possible types'
  - '**Interpreted**'
  - '**Garbage collected**'
  benefits:
  - "**Widely supported:** computers, phones, and even consoles use it. It's for websites, but can also create desktop and mobile applications with [node.js](https://nodejs.org/)"
  - '**Many resources,** including libraries (see [npm](https://www.npmjs.com/)), and online knowledge'
  - '**Flexible:** functions, objects, dictionaries, and sequences all belong to one type ("object"), and you can treat them as any type, e.g. you can create a function which is also an sequence'
  - 'Many different languages (PureScript, Scala.js, TypeScript) can be "transpiled" into JavaScript'
  drawbacks:
  - "**Hard to find bugs,** because buggy code doesn't always raise an error, due to strange semantics"
  - '**Strange semantics:** weird edge cases, e.g. `{} + []` is `0`, and `[] + {}` is `"[object Object]"`. [Source](https://yerevancoder.com/2018-03-06-javascript-edge-cases/)'
  - 'Generally **slow**, because it’s interpreted, although there are ways to optimize such as [WebAssembly](https://webassembly.org/)'
  useCases:
  - 'Websites'
  - 'Cross-platform applications'
  history: Originally written very quickly, designed for very simple programs (scripts) and named *Java*Script for marketing. Unexpectedly became very popular and now used for large programs. [Source](https://auth0.com/blog/a-brief-history-of-javascript/)
  example: |
    ```js
    function promptWidth() {
      return parseInt(prompt("Square width = ..."));
    }

    function printArea(square) {
      console.log("Square area = " + square.width * square.width);
    }

    const square = { width: promptWidth() };
    printArea(square); // Area = 2500
    ```
  tutorials:
  - https://javascript.info/
  - https://www.learn-js.org/
  - https://www.w3schools.com/js/
  - https://youtube.com/watch?v=PkZNo7MFNFg
- name: Python
  icon: python
  summary: Designed to write simple programs fast and not use "unnecessary" syntax like semicolons. [Source](https://www.artima.com/intv/pyscale.html)
  keyFeatures:
  - '**Object-oriented**, with some support for functional programming (lambdas)'
  - '**Interpreted**'
  - '**Weak types** with runtime checks, although there is minimal static type checking via [mypy](http://mypy-lang.org/)'
  benefits:
  - "**A good first language** because it's simple, used by many \"learn to code\" sites like [Codeacademy](https://www.codecademy.com/learn/learn-python)"
  - '**Concise:** designed so you can write code as fast as possible'
  - '**Good for AI:** Lots of Artificial Intelligence and math libraries are written in Python. [List](https://wiki.python.org/moin/)PythonForArtificialIntelligence]'
  drawbacks:
  - 'Not designed for large programs'
  - "**Slow** because it's interpreted"
  useCases:
  - 'Prototyping'
  - 'Artifical Intelligence'
  example: |
    ```python
    class Square:
      def __init__(self, width):
        self.width = width

      def getArea();
        return self.width * self.width

    width = int(input(“Square width = “))
    square = Square(width)
    print(“Square area = “, square.getArea())
    ```
  tutorials:
  - https://docs.python.org/3/tutorial/
  - https://www.learnpython.org/
  - https://www.w3schools.com/python/
  - https://youtube.com/watch?v=_uQrJ0TkZlc
- name: R
  icon: r
  summary: Flexible language often used for statistics
  keyFeatures:
  - "**Multi-paradigm:** Primarily functional, but supports objects, and because it's flexible it allows even more paradigms"
  - "**Weak types,** checked at runtime"
  - "**Interpreted**"
  - "**Garbage collected**"
  - "**Lazy:** evaluate expressions when they're read, not when they're defined. However, R is **not pure**, and the lazy expressions can cause \"side effects\" like reading/writing files or modifying variables. [Learn more](https://www.r-bloggers.com/about-lazy-evaluation/)"
  benefits:
  - "**Expressive:** Nearly complete control over semantics. For example, you can modify built-in statements like `if`, evaluate function arguments with different semantics, and create variables which modify other variables when read"
  - "Lots of **math and statistics** libraries. Useful for graphing, manipulating, and analyzing large datasets"
  - "**Quick to write,** since it’s interpreted, and has syntax sugar, many built-in utilities, and external libraries"
  drawbacks:
  - "**Confusing semantics:** expressivity means it’s hard to determine what code does simply by looking at it, since even reading a variable could affect other variables"
  - "**Inconsistent conventions.** Some libraries use camel-case, other use snake case. There are 3 different implementations of \"object\"s, and different libraries use different implementations"
  - "**Inefficient** because of flexibility, and compilers can’t infer enough to rewrite semantics"
  - "**Hard to write large programs** because of confusing semantics, inconsistency, and slowness"
  useCases:
  - "Complex mathematical calculations and graphing"
  history: Developed in the 1990s and still maintained today, named R because it was a version of the [S Language for Statistical Computing](https://www.whoishostingthis.com/resources/s-plus/)"
  example: |
    ```r
    getArea <- function(this, ...) {
      UseMethod("getArea", this)
    }

    getArea.square <- function(width) {
      width * width
    }

    width <- as.integer(readline(prompt = "Square width = "))
    square <- structure(width, class = "square")
    cat("Square area =", getArea(square), "\n")
    ```
  tutorials:
  - https://adv-r.hadley.nz/
  - https://youtube.com/watch?v=fDRa82lxzaU
efficient:
- name: Efficent
  icon: folder-benchmark
  summary: Designed to create fast, memory-efficient programs
  keyFeatures:
  - 'Usually **procedural**, model how computers actually execute code'
  - 'Almost always **compiled**'
  - 'Usually require **manual memory management**, because garbage collectors are slow and inefficient'
  benefits:
  - '**Fast**'
  drawbacks:
  - "**Verbose:** must explicitly mention memory-management and other low-level details, which other languages abstract"
  - "**Hard to fix bugs,** because there isn't memory management or other runtime checks"
  useCases:
  - 'Programs which perform heavy calculations, like weather predictors'
  - 'Video games which use high-end graphics'
  - 'Programs for embedded systems with small processors'
- name: C++
  icon: cpp
  summary: A preprocessor for C which adds much more abstraction, powerful but very complicated. [Source](https://stackoverflow.com/questions/713704/c-as-a-first-language/713735)
  keyFeatures:
  - 'Primarily **object-oriented** but has "ad-hoc" support for lambdas'
  - '**Weak types**, unchecked at runtime'
  - '**Compiled** to assembly'
  - '**Manual memory management**'
  benefits:
  - 'One of the **fastest** and **most memory-efficient** languages, equivalent to C'
  - 'Very **expressive:** templates let you almost completely change the syntax'
  - '**Popular:** used by many developers and companies. [Statistic](https://www.tiobe.com/tiobe-index/cplusplus/)'
  drawbacks:
  - '**Steep learning curve:** because it’s so flexible, very hard to write maintainable code'
  - '**Unsafe:** memory corruption errors are hard to find and can be exploited'
  - '**Verbose:** lots of code'
  - '**Confusing compiler errors**, especially with templates'
  useCases:
  - 'Fast embedded systems'
  - 'Competitive Programming'
  - 'Video games with advanced graphics'
  history: Released in the 1980s ([source](http://www.cs.mun.ca/~donald/bsc/node6.html)), but is constantly extended with new features even today ([current status](https://isocpp.org/std/status))
  example: |
    ```cpp
    #include <iostream>
    class Shape {
      public:
        virtual int getArea() = 0;
    };

    class Square : public Shape {
        int width;
      public:
        Square(int width) : width(width) {}
        int getArea() { return width * 2; }
    };

    int main() {
        std::cout << "Square width = ";
        int width;
        std::cin >> width;
        Square square(width);
        std::cout << "Square area = " << square.getArea();
        return 0;
    }
    ```
  tutorials:
  - https://www.learn-cpp.org/
  - https://www.cprogramming.com/tutorial/c++-tutorial.html
  - http://www.cs.ecu.edu/~karl/3510/notes1.html
  - https://www.youtube.com/watch?v=vLnPwxZdW4Y
- name: C
  icon: c
  summary: Old, simple language to write fast programs
  keyFeatures:
  - "**Procedural:** no lambdas or built-in objects, although there are structures"
  - "**Weak types,** unchecked casts (type mismatches can have unexpected effects)"
  - "**Compiled** to assembly"
  - "**Manual memory management,** with less abstraction than C++ and Rust"
  benefits:
  - "**Easier to learn** than C++ and Rust, because it's simple and doesn’t produce confusing compiler errors"
  - "**Direct:** because it's simpler, means that there are no \"hidden\" abstractions which can create bugs. Relatively straightforward translation to assembly and how computers (used to) execute code"
  - "**Portable:** the current C compiler is similar to the one from the 1990s, when computers were very old, so most C programs can be compiled and run on small processors"
  drawbacks:
  - "**Not much built-in abstraction,** so large programs written in C are often confusing"
  - "**Verbose:** not much syntax sugar or implicit code execution (e.g. destructors), especially with memory management"
  - "**Superseded by C++**: C++ offers all features of C, but also supports objects, templates and other abstraction"
  useCases:
  - "A good first efficient language"
  - "Learning about memory management and how computers run code"
  - "Programming on or for small computers"
  history: Developed in the 1970s, standardized in the 1980s, hasn't changed much since. [Source](https://www.bell-labs.com/usr/dmr/www/chist.html)
  example: |
    ```c
    #include <iostream>
    typedef struct {
      int width;
    } square;

    int getArea(square s) { return s.width * s.width; }

    int main() {
        printf("Square width = ");
        int width;
        scanf("%d", &width);
        square s = { width };
        printf("Square area = %d", getArea(s));
        return 0;
    }
    ```
  tutorials:
  - https://www.learn-c.org/
  - https://www.w3schools.in/c-tutorial/
  - https://www.youtube.com/watch?v=KJgsSFOSQv0
- name: Go
  icon: go
  summary: Simple language for fast, concurrent applications
  keyFeatures:
  - "**Multi-paradigm:** supports functions and object-like syntax, but doesn’t use advanced features of any paradigm (e.g. no classes, no currying)"
  - "**Strong types**, but only allows simple types (no classes or generics)"
  - "**Compiled** to assembly"
  - "**Garbage collected**"
  benefits:
  - "**Simple:** easy to learn"
  - "Encourages good programming for beginners, because it's strict"
  - "**Built-in support** for concurrency, servers, and more. [Main libraries](https://golang.org/pkg/)"
  drawbacks:
  - "**Not much abstraction**, so it can be hard to write large programs"
  - "Strictness can get in the way if you want to write code in a particular style"
  - "Usually **less efficient than C or C++**, because it's garbage collected"
  useCases:
  - "A good first efficient language"
  - "Modern fast programs"
  - "Servers, especially those run on distributed systems"
  history: Released in 2009 to be like C but simpler and more modern. [Source](https://golang.org/doc/faq#history), [blog describing Go's design](https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html)
  example: |
    ```go
    package main

    import "fmt"

    type square struct {
      width int
    }

    func (s square) area() int {
      return s.width * s.width;
    }

    func main() {
      fmt.Print("Square width = ")
      var s square
      fmt.Scan(&square.width)
      fmt.Println("Square area = ", square.area())
    }
    ```
  tutorials:
  - https://tour.golang.org/welcome/1
  - https://golangbot.com/learn-golang-series/
  - https://www.youtube.com/watch?v=Q0sKAMal4WQ
- name: Rust
  icon: rust
  summary: Enables fast, complete memory management, but catches memory corruption errors while compiling
  keyFreatures:
  - "**Multi-paradigm:** supports object-oriented and functional concepts"
  - "**Strong types**, can’t be casted"
  - "**Compiled** to assembly"
  - "**Manual memory management**, but the compiler practically ensures there is no possible memory corruption"
  benefits:
  - "**Safe and Fast:** has the benefits of manual memory management, without the drawback of hard-to-fix memory corruption errors"
  - "**Flexible:** includes macros which let you extend syntax, supports functional programming better than C and C++"
  - "**Good package management** with [cargo](https://doc.rust-lang.org/cargo/guide/)"
  drawbacks:
  - "**Steep learning curve:** code must be written in a special way, following rules like [ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) and [lifetimes](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html), so the compiler can prove it’s safe. This makes it hard to write code which even compiles"
  - "**Verbose:** You must explicitly code how your program manages its memory, using structures like [`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) and [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html). Most libraries also wrap code in [`Results`](https://doc.rust-lang.org/std/result/), which let you catch and handle errors, but often you simply want to unwrap or convert them"
  useCases:
  - "Efficient and secure programs"
  - "Efficient programs which don’t depend on C libraries or need C's portability"
  history: Rust started being developed in 2006, specifically to provide the efficiency of C / C++ without memory corruption errors. [Source](https://www.infoq.com/news/2012/08/Interview-Rust)
  example: |
    ```rust
    use std::io;

    trait Shape {
      fn get_area(&self) -> u32;
    }

    struct Square { width: u32 }

    impl Shape for Square {
      fn get_area(&self) -> u32 { return self.width * self.width; }
    }

    fn main() {
      print!("Square width = ");
      let mut input_text = String::new();
      io::stdin().read_line(&mut input_text).unwrap();
      let square = Square {
        width: input_text.trim().parse::<u32>().unwrap(),
      };
      println!("Square area = {}", square.get_area());
    }
    ```
  tutorials:
  - https://doc.rust-lang.org/rust-by-example/
  - https://doc.rust-lang.org/book/index.html
  - https://www.youtube.com/watch?v=vOMJlQ5B-M0
other:
- name: Other
  icon: folder-other
  summary: Don't fit into other categories, often unique and interesting
  benefits:
  - 'Usually more **interesting** than typical languages'
  - '**Teach** concepts which can be applied to typical languages'
  drawbacks:
  - 'Less **online support and resources** than typical languages, since less developers use them'
  - 'Often **harder to setup and debug**'
  useCases:
  - 'See individual languages, most have their own very specific use cases'
  - 'Learning / research'
  - 'Creative side projects'
- name: Haskell
  icon: haskell
  summary: A very unique language which is functional, pure, and lazy.
  keyFeatures:
  - "Explicitly **functional**, doesn't support objects"
  - '**Strong types**, supports complicated types such as [higher kinded types](https://gist.github.com/CMCDragonkai/a5638f50c87d49f815b8) and (to an extent) [dependent types](https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell), uses the [Hindley-Milner](http://dev.stephendiehl.com/fun/006_hindley_milner.html) type-system'
  - '**Compiled** to assembly, heavily optimized'
  - '**Garbage collected**'
  - '**Lazy:** doesn’t evaluate expressions "step by step", instead waits until they’re needed'
  - "**Pure:** can't modify values, e.g. if `x = 1` at one point in the code, `x` can't be set to `2` later"
  benefits:
  - '**Concise:** often requires much less code than other languages'
  - '**Safe:** because of strong type checking, most bugs are caught while compiling, so *once your code runs*, it takes much less time to debug'
  - '**Educational and interesting:** teaches unique programming concepts which can be applied to other languages'
  - '**Fast**, especially for a functional language, because of optimizations and lazy semantics'
  drawbacks:
  - '**Unpopular:** not used by many companies, hard to get a Haskell job. [Statistic](https://www.tiobe.com/tiobe-index/)'
  - '**Steep learning curve** because it’s so much different than other languages'
  - '**Hard to debug:** lazy semantics make evaluation very confusing, and because there isn’t any state, it’s hard to print expressions. [More info on debugging](https://wiki.haskell.org/Debugging)'
  - "**Hard to represent state:** because it's pure and lazy, not ideal for programs like video games or simulations, which model a sequence of actions and mutation"
  useCases:
  - 'Compilers'
  - 'Calculators'
  - 'Programs which "read an input and produce an output"'
  history: Developed in 1982, has an official, formal specification written in 2010.
  example: |
    ```hs
    import System.IO

    data Square = Square Int

    getArea :: Square -> Int
    getArea (Square width) = width * width

    main :: IO ()
    main = do
      putStr "Square width = "
      square <- Square . read <$> readLine
      putStr "Square area = "
      print $ getArea square
    ```
  tutorials:
  - https://www.haskell.org/
  - http://learnyouahaskell.com/
  - https://youtube.com/watch?v=02_H3LjqMr8
- name: Elixir
  icon: elixir
  summary: "Designed for **concurrent programs**: programs which use many threads or processes, like distributed systems"
  keyFeatures:
  - "**Functional**"
  - "**Weak types**, checked at runtime"
  - "**Compiled**"
  - "**Garbage collected**"
  benefits:
  - "Runs on the [Erlang](https://www.erlang.org/) Virtual Machine, which is well-tested, so it's safe and efficient"
  - "**Designed to handle errors,** so that the program can recover from them and keep running"
  drawbacks:
  - "Not ideal for programs which don't need concurrency, particularly programs which would be used by individual people, since there are already many languages designed for them"
  - "**Steep learning curve.** If you're familiar with languages like Java, you would need to learn functional and concurrent programming"
  - "**Not many resources,** because it's very new and different than other languages"
  useCases:
  - Programs which would be run on large servers
  history: Developed to function the same as [Erlang](https://www.erlang.org/), another concurrent language developed by Telecom companies, but with better syntax. [Source](https://elixir-lang.org)
  example: |
    ```elixir
    defmodule Square do
        def get_area(%{width: width}) do
            width * width
        end
    end

    input = IO.gets "Square width = "
    {width, _} = Integer.parse(input)
    IO.puts "Square area = "
    IO.puts(to_string(Square.get_area(%{width: width})))
    ```
  tutorials:
  - https://elixir-lang.org/learning.html
  - https://www.youtube.com/watch?v=pBNOavRoNL0
- name: OCaml
  icon: ocaml
  summary: Core, basic functional programming concepts like [Abstract Data Types] (small structures), with a powerful module system
  keyFeatures:
  - "**Functional:** Has support for objects, but many libraries like [Core] don’t use them"
  - "**Strong types**, can't be casted"
  - "**Compiled** to assembly"
  - "**Garbage collected**"
  benefits:
  - "**Great organization** because of powerful module system, which includes concepts like [\"functor modules\"]. [Learn more]"
  - "**Simple yet powerful:** doesn’t have many features, so it encourages good design and consistency, but it still enables a lot of abstraction"
  - "**Fast to compile,** because it’s very simple"
  drawbacks:
  - "**Unpopular:** not widely known, so there are less online resources"
  history: Released in 1996, added explicit object support to Caml, a version of an early language called ML (*Objective* Caml). Ironically, the objects aren't always used because modules provide similar functionality. [Source](https://ocaml.org/learn/history.html)
  example: |
    ```ocaml
    type square =
      { width: int;
      }

    let getArea square = square.width * square.width

    let main () =
      Printf.printf "Square width = ";
      let square = { width = read_int (); };
      Printf.printf "Square area = %f" (getArea square)
    ```
  tutorials:
  - http://www.ocaml.org/learn/
  - https://youtube.com/watch?v=xTsHMja8joA
- name: Prolog
  icon: prolog
  summary: "A common, Turing-complete logical programming language"
  keyFeatures:
  - "**Logical programming**: a unique computation model where statements are \"facts\" that describe a problem, and the interpreter tries to solve the problem like an equation"
  - "**Weak types**, checked at runtime. [Source](https://github.com/SWI-Prolog/roadmap/wiki/Prolog-type-system)"
  - "**Typically compiled**, although it depends on the compiler/interpreter implementation. [Source](https://stackoverflow.com/questions/37427094/prolog-a-compiled-or-interpreted-language-or-both)"
  - "**Automatic memory management**"
  benefits:
  - "Better at encoding logical relations, since you don't need to figure out how they would be interpreted like in a typical language, you can just write them out directly"
  - "**Interesting** because it's very unique"
  drawbacks:
  - "**Not much abstraction,** not as flexible as more modern languages"
  - "**Unpopular:** not many people know logical programming, not many resources"
  - "Old, and hasn't changed much since it was first created"
  useCases:
  - Interesting to learn
  example: |
    ```prolog
    area(square, X, X*X) :- !.
    ```
    The input
    ```prolog
    ?- area(square, 50, A)
    ```
    would print
    ```prolog
    A = 2500
    ```
  tutorials:
  - http://www.sjsu.edu/faculty/watkins/prolog.htm
  - https://www.youtube.com/watch?v=SykxWpFwMGs
- name: Scheme
  icon: scheme
  summary: Incredibly simple language, dialect of LISP, used in research and education but rarely in production
  keyFeatures:
  - "**Multi-paradigm.** Doesn't explicitly support objects, but you can extend the language and add them, as well as other paradigms paradigms like [logical](https://www.computerhope.com/jargon/l/logic-programming.htm)."
  - 'Usually **weak types**, but some dialects have strong types (e.g. [Racket](https://racket-lang.org/))'
  - 'Some dialects interpreted (e.g. [TinyScheme](http://tinyscheme.sourceforge.net/home.html)), others compiled (e.g. [Chez Scheme](https://cisco.github.io/ChezScheme/))'
  - '**Garbage collected**'
  benefits:
  - '**Extensible:** macros can change practically all semantics (everything but syntax)'
  - "Easy to thoroughly understand and write an interpreter for, because it's very simple"
  drawbacks:
  - '**Unpopular:** practically impossible to find a non-research job'
  - "Most dialects **not usable in practice**, because some don't support visual output or I/O"
  - '**Slow:** even when compiled, slower than languages like C'
  useCases:
  - 'Good first language to write a compiler for'
  - 'Teaching / learning core programming concepts'
  history: A very old language developed in the 1970s, there are many different versions. [Source](https://web.archive.org/web/20060615225746/http://www.brics.dk/~hosc/local/HOSC-11-4-pp399-404.pdf)
  example: |
    Works in most dialects, including [MIT Scheme](http://web.mit.edu/~axch/www/scheme/choices/mit-scheme.html) and [Racket](https://racket-lang.org/)
    ```scheme
    (define (area-of-square square)
      (let ([width (cadr square)]))
        (* width width)))

    (display "Square width = ")
    (define input (read))
    (display "Square area = ")
    (print (area-of-square `(square ,(input))))
    ```
  tutorials:
  - https://groups.csail.mit.edu/mac/projects/scheme/
  - https://schemers.org/
  - https://youtube.com/watch?v=6k78c8EctXI
