general:
- name: General
  summary: '"All around", not specialized for one type of project, instead designed for any project'
  keyFeatures:
  - '**Multi-paradigm:** most are primarily **object-oriented**, but enable many different paradigms'
  - 'Almost always **compiled**'
  - 'Usually **garbage collected**, designed for ease-of-use over speed'
  benefits:
  - "Usually **flexible:** support many code paradigms and styles"
  drawbacks:
  - '**Harder to setup** than scripting languages, since they must be compiled'
  useCases:
  - 'Large programs'
  - 'Indie games, side projects, etc.'
  - "Any program which isn't very small and speed isn't important"
- name: Java
  summary: Currently the most popular, widely-used language. [Source](https://sdtimes.com/softwaredev/report-the-top-three-programming-languages-of-2018-are-java-javascript-and-python/)
  keyFeatures:
  - 'Strictly adheres to the **object-oriented** paradigm'
  - '**Weak types**, checked at runtime'
  - '**Compiled** to JVM bytecode, which runs on many different machines'
  - '**Garbage collected**'
  benefits:
  - '**Most popular:** lots of online resources, very likely to find a job. [Statistic](https://www.tiobe.com/tiobe-index/java/)'
  - '**Encourages good design** for beginners, because it has strict rules. e.g. all code must be implemented in classes, every class must be in its own file'
  - '**Easy to setup and debug:** Well-supported by multiple IDEs, including [Eclipse](https://www.eclipse.org/) and [IntelliJ IDEA](https://www.jetbrains.com/idea/)'
  drawbacks:
  - '**Verbose:** programs require lots of code and files'
  - '**Hard to use other paradigms** (e.g. functional) because of strict rules, and sometimes require you to write code in unintuitive ways.'
  - '**Slow:** runtime type checking and JVM make the language slower'
  useCases:
  - 'General programs'
  - 'Teaching / learning to code'
  - 'Cross-platform programs or embedded systems'
  history: Developed by Oracle in 1995 for websites. Ironically, now used by many other systems but not common in websites anymore. [Source](https://mathbits.com/MathBits/Java/Introduction/BriefHistory.htm)
  example: |
    ```java
    interface Shape {
      int getArea();
    }

    class Square implements Shape {
      private int width;
      public Square(int w) { width = w; }
      public int getArea() { return width * width; }
    }

    class Main {
      public static void main(String[] args) {
        System.out.print("Square width = ");
        Scanner input = new Scanner(System.in);
        Square square = new Square(input.nextInt());
        System.out.println("Square area = " + square.getArea());
      }
    }
    ```
  tutorials:
  - https://www.w3schools.com/java/java_intro.asp
  - http://interactivepython.org/runestone/static/JavaReview/JavaBasics/JavaBasicsSummary.html
  - https://www.tutorialspoint.com/java/java_tutorial.pdf
- name: Scala
  summary: Designed to improve Java by being more concise and better supporting functional programming
  keyFeatures:
  - "Both **object-oriented and functional** - you can choose either paradigm or mix both"
  - "**Strong types** checked at compile-time, can force casts checked at runtime"
  - "**Compiled** to JVM bytecode"
  - "**Garbage collected**"
  benefits:
  - '**Extensible:** Almost the entire syntax can be rewritten (see ["Baysic" - BASIC code in Scala](https://www.scala-lang.org/old/node/1403))'
  - "**Safe:** Strong types mean that most bugs are spotted when code is compiled, not run"
  - "**Compatible with Java:** Scala code can use Java libraries, and vice versa"
  - "**Easy to setup and debug:** Supported by [IntelliJ IDEA](https://www.jetbrains.com/idea/) and [Eclipse](http://scala-ide.org/)"
  drawbacks:
  - "**Steep learning curve:** Not as unique as Haskell, but harder to learn than Java"
  - >
    **Confusing compiler errors:** Many libraries use "implicits”, which are usually inferred by the compiler, but when they can’t be inferred, they're tough to debug
  useCases:
  - "When you don't want to use Java but want / need Java libraries"
  - 'Web servers (see [Play Framework](https://www.playframework.com/)) and clients (see [Scala.js](https://www.scala-js.org/))'
  - 'Very large applications'
  example: |
    ```scala
    trait Shape {
      def getArea(): Int
    }

    case class Square(width: Int) extends Shape {
      override def getArea(): Int = width * width
    }

    object Main {
      def main(args: Array[String]): Unit = {
        print("Square width = ")
        val square = Square(scala.io.StdIn.readInt())
        println(s"Square area = ${square.getArea()}")
      }
    }
    ```
  tutorials:
  - https://docs.scala-lang.org/tutorials/tour/tour-of-scala.html.html
  - https://www.scala-exercises.org/std_lib/asserts
  - http://allaboutscala.com/#scala-introduction
- name: Swift
  summary: Developed by Apple for writing programs for macOS, iOS, and other Apple operating systems. [Source](https://developer.apple.com/swift/)
  keyFeatures:
  - '**Object-oriented** and **functional**. [Source](https://skookum.com/blog/swift-blurs-the-lines-of-programming-paradigms)'
  - '**Strong types**, casts checked at runtime'
  - '**Compiled** to assembly'
  - 'Requires **some explicit memory management** - uses [automatic reference counting](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)'
  benefits:
  - '**Concise:** has a lot of syntactic sugar, and often uses "structures" which are like objects but require less code'
  - '**Fast:** automatic reference counting and focus on performance make Swift faster than other general-purpose languages like Java, although usually not as fast as C'
  - '**Supported:** easy to setup and debug with [Xcode](https://developer.apple.com/xcode/), many online tutorials'
  drawbacks:
  - '**Not supported on many non-macOS platforms:** although there is minimal Linux support, many libraries and other features are missing'
  - 'Sometimes slows down and crashes the Xcode IDE, because of its complicated syntax'
  useCases:
  - 'iOS, watchOS, or Mac-specific apps'
  history: Developed in 2010 and released in 2014, intended to replace Objective-C and thus make it easier to program Mac and iOS applications. [Source](https://www.cleverism.com/skills-and-tools/swift/)
  example: |
    ```swift
    import Foundation

    protocol Shape {
      func getArea() -> Int
    }

    struct Square: Shape {
      let width: Int
      func getArea() -> Int { return width * width; }
    }

    print("Square width = ");
    let square = Square(width: Int(readLine()!));
    println("Square area = \(square.getArea())");
    ```
  tutorials:
  - https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-ID1
  - https://www.tutorialspoint.com/swift/swift_tutorial.pdf
  - https://www.raywenderlich.com/6338-swift-tutorial-part-1-expressions-variables-and-constants
scripting:
- name: Scripting
  summary: "Designed to write code fast, even if it isn't maintainable long-term"
  keyFeatures:
  - 'Usually **weak types**, since explicit type annotations require more code'
  - 'Usually **interpreted**'
  - 'Always **garbage collected** or have some other automatic memory management'
  benefits:
  - 'Usually **easy and quick** to setup'
  - 'Code doesn’t need to be recompiled, saving time during development'
  drawbacks:
  - 'Interpreted programs run slower than compiled programs'
  useCases:
  - 'Simple programs'
  - 'Prototypes for larger programs'
  - 'Programming exercises'
- name: JavaScript
  summary: The "programming language of the web", used to add dynamic content to websites. [Source](https://www.w3schools.com/js/), [More info](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
  keyFeatures:
  - '“Ad-hoc” object-oriented but supports first class functions'
  - 'No types at compile-time, minimal at runtime'
  - 'Interpreted'
  - 'Garbage collected'
  benefits:
  - "**Widely supported:** computers, phones, and even consoles use it. It's for websites, but can also create [desktop] and [mobile] applications with [node.js](https://nodejs.org/)"
  - '**Many resources:** libraries (see [npm](https://www.npmjs.com/)), and online knowledge'
  - '**Expressive:** you can structure your code how you want'
  - 'Many different languages (PureScript, Scala.js, TypeScript) can be "transpiled" into JavaScript.'
  drawbacks:
  - '**Hard to find bugs:** almost no runtime errors'
  - '**Strange semantics:** weird edge cases, e.g. `{} + []` is `0`, and `[] + {}` is `"[object Object]"`. [Source](https://yerevancoder.com/2018-03-06-javascript-edge-cases/)'
  - 'Generally **slow**, because it’s interpreted, although there are ways to optimize such as [WebAssembly](https://webassembly.org/)'
  useCases:
  - 'Websites'
  - 'Cross-platform applications'
  history: Originally written very quickly, designed for very simple programs (scripts) and named *Java*Script for marketing. Unexpectedly became very popular and now used for large programs. [Source](https://auth0.com/blog/a-brief-history-of-javascript/)
  example: |
    ```js
    function promptWidth() {
      return parseInt(prompt("Square width = ..."));
    }

    function printArea(square) {
      console.log("Square area = " + square.width * square.width);
    }

    var square = { width: promptWidth() };
    printArea(square); // Area = 2500
    ```
  tutorials:
  - https://javascript.info/
  - https://www.learn-js.org/
  - https://www.w3schools.com/js/
- name: Python
  summary: Designed to write simple programs fast and not use "unnecessary" syntax like semicolons. [Source](https://www.artima.com/intv/pyscale.html)
  keyFeatures:
  - '**Procedural** and **object-oriented**, with minimal support for functional programming'
  - '**Interpreted**'
  - '**Weak types** with runtime checks, although there is minimal static type checking via [mypy](http://mypy-lang.org/)'
  benefits:
  - '**Simple:** a good first language'
  - '**Concise:** designed so you can write code as fast as possible'
  - '**Good for AI:** Lots of Artificial Intelligence and math libraries are written in Python. [List](https://wiki.python.org/moin/)PythonForArtificialIntelligence]'
  drawbacks:
  - '**Difficult to structure large programs:** encourages design patterns which produce working code in the short term, but make it hard to extend in the long-term'
  - "**Slow** because it's interpreted"
  useCases:
  - 'Prototyping'
  - 'Artifical Intelligence'
  example: |
    ```python

    function promptWidth() {
      return parseInt(prompt("Square width = ..."));
    }

    function printArea(square) {
      console.log("Square area = " + square.width * square.width);
    }

    print("Square width = ")
    square = new Square(int(raw_input()))
    print("Square area = " + square.getArea())
    ```
  tutorials:
  - https://docs.python.org/3/tutorial/
  - https://www.learnpython.org/
  - https://www.w3schools.com/python/
efficient:
- name: Efficent
  summary: Designed to create fast, memory-efficient programs
  keyFeatures:
  - 'Usually **procedural**, model how computers actually execute code'
  - 'Almost always **compiled**'
  - 'Usually require **manual memory management**, because garbage collectors are slow and inefficient'
  benefits:
  - '**Fast**'
  drawbacks:
  - "**Verbose:** must explicitly mention memory-management and other low-level details, which other languages abstract"
  - "**Hard to fix bugs** because there isn't memory management or other runtime checks"
  useCases:
  - 'Programs which perform heavy calculations, like weather predictors'
  - 'Video games which use high-end graphics'
  - 'Programs for embedded systems with small processors'
- name: C++
  summary: A preprocessor for C which adds much more abstraction, powerful but very complicated. [Source](https://stackoverflow.com/questions/713704/c-as-a-first-language/713735)
  keyFeatures:
  - '**Object-oriented** but supports first class functions'
  - '**Weak types**, unchecked at runtime'
  - '**Compiled** to assembly'
  - '**Manual memory management**'
  benefits:
  - 'One of the **fastest** and **most memory-efficient** languages, equivalent to C'
  - 'Very **expressive:** templates let you almost completely change the syntax'
  - '**Popular:** used by many developers and companies. [Statistic](https://www.tiobe.com/tiobe-index/cplusplus/)'
  drawbacks:
  - '**Steep learning curve:** because it’s so flexible, very hard to write maintainable code'
  - '**Unsafe:** memory corruption errors are hard to find and can be exploited'
  - '**Verbose:** lots of code'
  - '**Confusing compiler errors**, especially with templates'
  useCases:
  - 'Fast embedded systems'
  - 'Competitive Programming'
  - 'Video games with advanced graphics'
  history: Released in the 1980s ([source](http://www.cs.mun.ca/~donald/bsc/node6.html)), but is constantly extended with new features even today ([current status](https://isocpp.org/std/status))
  example: |
    ```cpp
    #include <iostream>
    class Shape {
      public:
        virtual int getArea() = 0;
    };

    class Square : public Shape {
        int width;
      public:
        Square(int width) : width(width) {}
        int getArea() { return width * 2; }
    };

    int main() {
        std::cout << "Square width = ";
        int width;
        std::cin >> width;
        Square square(width);
        std::cout << "Square area = " << square.getArea();
        return 0;
    }
    ```
  tutorials:
  - https://www.learn-cpp.org/
  - https://www.cprogramming.com/tutorial/c++-tutorial.html
  - http://www.cs.ecu.edu/~karl/3510/notes1.html
- name: C
  summary: Old, very simple language to write fast programs
  keyFeatures:
  - "**Procedural:** you must implement objects yourself, minimal support for functional programming"
  - "**Weak types** and unchecked casts"
  - "**Compiled** to assembly"
  - "**Manual memory management** with less abstraction than C++ and Rust"
  benefits:
  - "**Simple:** **easier to learn** than C++ and Rust, doesn’t produce confusing compiler errors"
  - "**Direct:** simplicity means that there are no “hidden” abstractions which can create bugs. Relatively straightforward translation to assembly and how computers (used to) execute code"
  - "**Small:** The current C compiler is similar to the one from the 1990s, when computers were very old, so most C programs can be compiled and run on small processors"
  drawbacks:
  - "**Hard to abstract:** this makes it hard to represent complicated logic without making it confusing"
  - "**Verbose:** not much syntax sugar, memory management logic must be written out more than other languages"
  - "**Superseded** by C++: C++ offers all features of C, but also supports objects, templates and other abstractions"
  useCases:
  - "Efficient language for beginners"
  - "Learning about memory management and how computers run code"
  - "Processors with small compilers"
  history: Developed in the 1970s, standardized in the 1980s, hasn't changed much since. [Source](https://www.bell-labs.com/usr/dmr/www/chist.html)
  example: |
    ```c
    #include <iostream>
    typedef struct {
      int width;
    } square;

    int getArea(square s) { return s.width * s.width; }

    int main() {
        printf("Square width = ");
        int width;
        scanf("%d", &width);
        square s = { width };
        printf("Square area = %d", getArea(s));
        return 0;
    }
    ```
  tutorials:
  - https://www.learn-c.org/
  - https://www.w3schools.in/c-tutorial/
  - https://www.cprogramming.com/tutorial/c-tutorial.html
- name: Rust
  summary: Enables fast, complete memory management, but catches memory corruption errors while compiling
  keyFreatures:
  - "**Multi-paradigm:** Supports object-oriented, procedural, and functional paradigms"
  - "**Strong types**, can’t be casted"
  - "**Compiled** to assembly"
  - "**Manual memory management**, but the compiler practically ensures that there is no possible memory corruption"
  benefits:
  - "**Safe and Fast:** Allows you to store memory in an optimal way and gives other benefits of manual memory management, without the drawback of hard-to-fix memory corruption"
  - "**Flexible:** includes macros which let you extend syntax, supports functional programming better than C and C++"
  - "**Good package management** with [cargo](https://doc.rust-lang.org/cargo/guide/)"
  drawbacks:
  - "**Steep learning curve:** code must be written in a special way, following rules like [ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) and [lifetimes](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html), so the compiler can prove it’s safe. This makes it hard to write code which even compiles"
  - "**Verbose:** You must explicitly code how your program manages its memory, using structures like [`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) and [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html). Most libraries also wrap code in [`Results`](https://doc.rust-lang.org/std/result/), which let you catch and handle errors, but often you simply want to unwrap or convert them"
  useCases:
  - "Efficient new programs, which don’t depend on C libraries"
  - "Efficient secure programs"
  history: Rust started being developed in 2006, specifically to provide the efficiency of C / C++ without memory corruption errors. [Source](https://www.infoq.com/news/2012/08/Interview-Rust)
  example: |
    ```rust
    use std::io;

    trait Shape {
      fn get_area(&self) -> u32;
    }

    struct Square { width: u32 }

    impl Shape for Square {
      fn get_area(&self) -> u32 { return self.width * self.width; }
    }

    fn main() {
      print!("Square width = ");
      let mut input_text = String::new();
      io::stdin().read_line(&mut input_text).unwrap();
      let square = Square {
        width: input_text.trim().parse::<u32>().unwrap(),
      };
      println!("Square area = {}", square.get_area());
    }
    ```
  tutorials:
  - https://doc.rust-lang.org/rust-by-example/
  - https://doc.rust-lang.org/book/index.html
  - https://stevedonovan.github.io/rust-gentle-intro/
other:
- name: Other
  summary: Don't fit into other categories, often unique and interesting
  benefits:
  - 'Usually more **interesting** than typical languages'
  - '**Teach** concepts which can be applied to typical languages'
  drawbacks:
  - 'Less **online support and resources** than typical languages, since less developers use them'
  - 'Often **harder to setup and debug**'
  useCases:
  - 'See individual languages, most have their own very specific use cases'
  - 'Learning / research'
  - 'Creative side projects'
- name: Haskell
  summary: A very unique language which is functional, pure, and lazy.
  keyFeatures:
  - '**Lazy:** doesn’t evaluate expressions "step by step", instead waits until they’re needed'
  - "**Pure:** can't modify values, e.g. if `x = 1` at one point in the code, `x` can't be set to `2` later"
  - 'Functional'
  - '**Strong types**, supports complicated types such as [higher kinded types](https://gist.github.com/CMCDragonkai/a5638f50c87d49f815b8) and (to an extend) [dependent types](https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell), uses the [Hindley-Milner](http://dev.stephendiehl.com/fun/006_hindley_milner.html) type-system'
  - '**Compiled** to assembly, heavily optimized'
  - '**Garbage collected**'
  benefits:
  - '**Concise:** often requires much less code than other languages'
  - '**Safe:** because of strong type checking, most bugs are caught while compiling, so *once your code runs*, it takes much less time to debug'
  - '**Educational and interesting:** teaches unique programming concepts which can be applied to other languages'
  - '**Fast**, especially for a functional language, because of optimizations and lazy semantics'
  drawbacks:
  - '**Unpopular:** not used by many companies, hard to get a Haskell job. [Statistic](https://www.tiobe.com/tiobe-index/)'
  - '**Steep learning curve** because it’s so much different than other languages'
  - '**Hard to debug:** lazy semantics make evaluation very confusing, and because there isn’t any state, it’s hard to print expressions. [More info on debugging](https://wiki.haskell.org/Debugging)'
  - "**Hard to represent state:** because it's pure and lazy, not ideal for programs like video games or simulations, which model a sequence of actions and mutation"
  useCases:
  - 'Compilers'
  - 'Calculators'
  - 'Programs which “read an input and produce an output”'
  history: Developed in 1982, has an official, formal specification written in 2010.
  example: |
    ```hs
    import System.IO

    data Square = Square Int

    getArea :: Square -> Int
    getArea (Square width) = width * width

    main :: IO ()
    main = do
      putStr "Square width = "
      square <- Square . read <$> readLine
      putStr "Square area = "
      print $ getArea square
    ```
  tutorials:
  - https://www.haskell.org/
  - http://learnyouahaskell.com/
  - https://www.tutorialspoint.com/haskell/haskell_overview.htm
- name: Scheme
  summary: Incredibly simple language, dialect of LISP, used in research and education but rarely in production
  keyFeatures:
  - "**No specific paradigm (multi-paradigm)** - can write functional, procedural, object-oriented, even atypical paradigms like [logical](https://www.computerhope.com/jargon/l/logic-programming.htm)."
  - 'Usually **weak types**, but some dialects have strong types [e.g. (Racket](https://racket-lang.org/))'
  - 'Some dialects interpreted [e.g. (TinyScheme)[http://tinyscheme.sourceforge.net/home.html]), others compiled (e.g. (Chez Scheme](https://cisco.github.io/ChezScheme/))'
  - '**Garbage collected**'
  benefits:
  - '**Extensible:** macros can change almost all semantics (almost everything but syntax)'
  - '**Simple:** Very easy to understand and write an interpreter for'
  drawbacks:
  - '**Unpopular:** Practically impossible to find a non-research job'
  - "Most dialects **not usable in practice**, some don't support visual output or I/O, an exception is [Racket](https://racket-lang.org/)"
  - '**Slow:** even when compiled, slower than languages like C'
  useCases:
  - 'Teaching / learning'
  - 'Good first language to write a compiler for'
  history: A very old language developed in the 1970s, there are many different versions. [Source](https://web.archive.org/web/20060615225746/http://www.brics.dk/~hosc/local/HOSC-11-4-pp399-404.pdf)
  example: |
    Works in most dialects, including [MIT Scheme]()
    ```scm
    (define (area-of-square square)
      (let ([width (cadr square)]))
        (* width width)))

    (display "Square width = ")
    (define input (read))
    (display "Square area = ")
    (print (area-of-square `(square ,(input))))
    ```
  tutorials:
  - https://groups.csail.mit.edu/mac/projects/scheme/
  - https://schemers.org/
  - http://www.shido.info/lisp/idx_scm_e.html
