{"general": [{"name": "General", "summary": "\"All around\", not specialized for one type of project, instead designed for any project", "keyFeatures": ["**Multi-paradigm:** most are primarily **object-oriented**, but enable many different paradigms", "Almost always **compiled**", "Usually **garbage collected**, designed for ease-of-use over speed"], "benefits": ["Usually **flexible:** support many code paradigms and styles"], "drawbacks": ["**Harder to setup** than scripting languages, since they must be compiled"], "useCases": ["Large programs", "Indie games, side projects, etc.", "Any program which isn't very small and speed isn't important"]}, {"name": "Java", "summary": "Currently the most popular, widely-used language. [Source](https://sdtimes.com/softwaredev/report-the-top-three-programming-languages-of-2018-are-java-javascript-and-python/)", "keyFeatures": ["Strictly adheres to the **object-oriented** paradigm", "**Weak types**, checked at runtime", "**Compiled** to JVM bytecode, which runs on many different machines", "**Garbage collected**"], "benefits": ["**Most popular:** lots of online resources, very likely to find a job. [Statistic](https://www.tiobe.com/tiobe-index/java/)", "**Encourages good design** for beginners, because it has strict rules. e.g. all code must be implemented in classes, every class must be in its own file", "**Easy to setup and debug:** Well-supported by multiple IDEs, including [Eclipse](https://www.eclipse.org/) and [IntelliJ IDEA](https://www.jetbrains.com/idea/)"], "drawbacks": ["**Verbose:** programs require lots of code and files", "**Hard to use other paradigms** (e.g. functional) because of strict rules, and sometimes require you to write code in unintuitive ways.", "**Slow:** runtime type checking and JVM make the language slower"], "useCases": ["General programs", "Teaching / learning to code", "Cross-platform programs or embedded systems"], "history": "Developed by Oracle in 1995 for websites. Ironically, now used by many other systems but not common in websites anymore. [Source](https://mathbits.com/MathBits/Java/Introduction/BriefHistory.htm)", "example": "```java\ninterface Shape {\n  int getArea();\n}\n\nclass Square implements Shape {\n  private int width;\n  public Square(int w) { width = w; }\n  public int getArea() { return width * width; }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    System.out.print(\"Square width = \");\n    Scanner input = new Scanner(System.in);\n    Square square = new Square(input.nextInt());\n    System.out.println(\"Square area = \" + square.getArea());\n  }\n}\n```\n", "tutorials": ["https://www.w3schools.com/java/java_intro.asp", "http://interactivepython.org/runestone/static/JavaReview/JavaBasics/JavaBasicsSummary.html", "https://www.tutorialspoint.com/java/java_tutorial.pdf"]}, {"name": "Scala", "summary": "Designed to improve Java by being more concise and better supporting functional programming", "keyFeatures": ["Both **object-oriented and functional** - you can choose either paradigm or mix both", "**Strong types** checked at compile-time, can force casts checked at runtime", "**Compiled** to JVM bytecode", "**Garbage collected**"], "benefits": ["**Extensible:** Almost the entire syntax can be rewritten (see [\"Baysic\" - BASIC code in Scala](https://www.scala-lang.org/old/node/1403))", "**Safe:** Strong types mean that most bugs are spotted when code is compiled, not run", "**Compatible with Java:** Scala code can use Java libraries, and vice versa", "**Easy to setup and debug:** Supported by [IntelliJ IDEA](https://www.jetbrains.com/idea/) and [Eclipse](http://scala-ide.org/)"], "drawbacks": ["**Steep learning curve:** Not as unique as Haskell, but harder to learn than Java", "**Confusing compiler errors:** Many libraries use \"implicits\u201d, which are usually inferred by the compiler, but when they can\u2019t be inferred, they're tough to debug\n"], "useCases": ["When you don't want to use Java but want / need Java libraries", "Web servers (see [Play Framework](https://www.playframework.com/)) and clients (see [Scala.js](https://www.scala-js.org/))", "Very large applications"], "example": "```scala\ntrait Shape {\n  def getArea(): Int\n}\n\ncase class Square(width: Int) extends Shape {\n  override def getArea(): Int = width * width\n}\n\nobject Main {\n  def main(args: Array[String]): Unit = {\n    print(\"Square width = \")\n    val square = Square(scala.io.StdIn.readInt())\n    println(s\"Square area = ${square.getArea()}\")\n  }\n}\n```\n", "tutorials": ["https://docs.scala-lang.org/tutorials/tour/tour-of-scala.html.html", "https://www.scala-exercises.org/std_lib/asserts", "http://allaboutscala.com/#scala-introduction"]}, {"name": "Swift", "summary": "Developed by Apple for writing programs for macOS, iOS, and other Apple operating systems. [Source](https://developer.apple.com/swift/)", "keyFeatures": ["**Object-oriented** and **functional**. [Source](https://skookum.com/blog/swift-blurs-the-lines-of-programming-paradigms)", "**Strong types**, casts checked at runtime", "**Compiled** to assembly", "Requires **some explicit memory management** - uses [automatic reference counting](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)"], "benefits": ["**Concise:** has a lot of syntactic sugar, and often uses \"structures\" which are like objects but require less code", "**Fast:** automatic reference counting and focus on performance make Swift faster than other general-purpose languages like Java, although usually not as fast as C", "**Supported:** easy to setup and debug with [Xcode](https://developer.apple.com/xcode/), many online tutorials"], "drawbacks": ["**Not supported on many non-macOS platforms:** although there is minimal Linux support, many libraries and other features are missing", "Sometimes slows down and crashes the Xcode IDE, because of its complicated syntax"], "useCases": ["iOS, watchOS, or Mac-specific apps"], "history": "Developed in 2010 and released in 2014, intended to replace Objective-C and thus make it easier to program Mac and iOS applications. [Source](https://www.cleverism.com/skills-and-tools/swift/)", "example": "```swift\nimport Foundation\n\nprotocol Shape {\n  func getArea() -> Int\n}\n\nstruct Square: Shape {\n  let width: Int\n  func getArea() -> Int { return width * width; }\n}\n\nprint(\"Square width = \");\nlet square = Square(width: Int(readLine()!));\nprintln(\"Square area = \\(square.getArea())\");\n```\n", "tutorials": ["https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-ID1", "https://www.tutorialspoint.com/swift/swift_tutorial.pdf", "https://www.raywenderlich.com/6338-swift-tutorial-part-1-expressions-variables-and-constants"]}], "scripting": [{"name": "Scripting", "summary": "Designed to write code fast, even if it isn't maintainable long-term", "keyFeatures": ["Usually **weak types**, since explicit type annotations require more code", "Usually **interpreted**", "Always **garbage collected** or have some other automatic memory management"], "benefits": ["Usually **easy and quick** to setup", "Code doesn\u2019t need to be recompiled, saving time during development"], "drawbacks": ["Interpreted programs run slower than compiled programs"], "useCases": ["Simple programs", "Prototypes for larger programs", "Programming exercises"]}, {"name": "JavaScript", "summary": "The \"programming language of the web\", used to add dynamic content to websites. [Source](https://www.w3schools.com/js/), [More info](https://developer.mozilla.org/en-US/docs/Web/JavaScript)", "keyFeatures": ["\u201cAd-hoc\u201d object-oriented but supports first class functions", "No types at compile-time, minimal at runtime", "Interpreted", "Garbage collected"], "benefits": ["**Widely supported:** computers, phones, and even consoles use it. It's for websites, but can also create [desktop] and [mobile] applications with [node.js](https://nodejs.org/)", "**Many resources:** libraries (see [npm](https://www.npmjs.com/)), and online knowledge", "**Expressive:** you can structure your code how you want", "Many different languages (PureScript, Scala.js, TypeScript) can be \"transpiled\" into JavaScript."], "drawbacks": ["**Hard to find bugs:** almost no runtime errors", "**Strange semantics:** weird edge cases, e.g. `{} + []` is `0`, and `[] + {}` is `\"[object Object]\"`. [Source](https://yerevancoder.com/2018-03-06-javascript-edge-cases/)", "Generally **slow**, because it\u2019s interpreted, although there are ways to optimize such as [WebAssembly](https://webassembly.org/)"], "useCases": ["Websites", "Cross-platform applications"], "history": "Originally written very quickly, designed for very simple programs [scripts) and named *Java*Script for marketing. Unexpectedly became very popular and now used for large programs. [Source](https://auth0.com/blog/a-brief-history-of-javascript/)", "example": "```js\nfunction promptWidth() {\n  return parseInt(prompt(\"Square width = ...\"));\n}\n\nfunction printArea(square) {\n  console.log(\"Square area = \" + square.width * square.width);\n}\n\nvar square = { width: promptWidth() };\nprintArea(square); // Area = 2500\n```\n", "tutorials": ["https://javascript.info/", "https://www.learn-js.org/", "https://www.w3schools.com/js/"]}, {"name": "Python", "summary": "Designed to write simple programs fast and not use \"unnecessary\" syntax like semicolons. [Source](https://www.artima.com/intv/pyscale.html)", "keyFeatures": ["**Procedural** and **object-oriented**, with minimal support for functional programming", "**Interpreted**", "**Weak types** with runtime checks, although there is minimal static type checking via [mypy](http://mypy-lang.org/)"], "benefits": ["**Simple:** a good first language", "**Concise:** designed so you can write code as fast as possible", "**Good for AI:** Lots of Artificial Intelligence and math libraries are written in Python. [List](https://wiki.python.org/moin/)PythonForArtificialIntelligence]"], "drawbacks": ["**Difficult to structure large programs:** encourages design patterns which produce working code in the short term, but make it hard to extend in the long-term", "**Slow** because it's interpreted"], "useCases": ["Prototyping", "Artifical Intelligence"], "example": "```python\n\nfunction promptWidth() {\n  return parseInt(prompt(\"Square width = ...\"));\n}\n\nfunction printArea(square) {\n  console.log(\"Square area = \" + square.width * square.width);\n}\n\nprint(\"Square width = \")\nsquare = new Square(int(raw_input()))\nprint(\"Square area = \" + square.getArea())\n```\n", "tutorials": ["https://docs.python.org/3/tutorial/", "https://www.learnpython.org/", "https://www.w3schools.com/python/"]}], "efficient": [{"name": "Efficent", "summary": "Designed to create fast, memory-efficient programs", "keyFeatures": ["Usually **procedural**, model how computers actually execute code", "Almost always **compiled**", "Usually require **manual memory management**, because garbage collectors are slow and inefficient"], "benefits": ["**Fast**"], "drawbacks": ["**Verbose:** must explicitly mention memory-management and other low-level details, which other languages abstract", "**Hard to fix bugs** because there isn't memory management or other runtime checks"], "useCases": ["Programs which perform heavy calculations, like weather predictors", "Video games which use high-end graphics", "Programs for embedded systems with small processors"]}, {"name": "C++", "summary": "A preprocessor for C which adds much more abstraction, powerful but very complicated. [Source](https://stackoverflow.com/questions/713704/c-as-a-first-language/713735)", "keyFeatures": ["**Object-oriented** but supports first class functions", "**Weak types**, unchecked at runtime", "**Compiled** to assembly", "**Manual memory management**"], "benefits": ["One of the **fastest** and **most memory-efficient** languages, equivalent to C", "Very **expressive:** templates let you almost completely change the syntax", "**Popular:** used by many developers and companies. [Statistic](https://www.tiobe.com/tiobe-index/cplusplus/)"], "drawbacks": ["**Steep learning curve:** because it\u2019s so flexible, very hard to write maintainable code", "**Unsafe:** memory corruption errors are hard to find and can be exploited", "**Verbose:** lots of code", "**Confusing compiler errors**, especially with templates"], "useCases": ["Fast embedded systems", "Competitive Programming", "Video games with advanced graphics"], "history": "Released in the 1980s ([source](http://www.cs.mun.ca/~donald/bsc/node6.html)), but is constantly extended with new features even today ([current status](https://isocpp.org/std/status))", "example": "```cpp\n#include <iostream>\nclass Shape {\n  public:\n    virtual int getArea() = 0;\n};\n\nclass Square : public Shape {\n    int width;\n  public:\n    Square(int width) : width(width) {}\n    int getArea() { return width * 2; }\n};\n\nint main() {\n    std::cout << \"Square width = \";\n    int width;\n    std::cin >> width;\n    Square square(width);\n    std::cout << \"Square area = \" << square.getArea();\n    return 0;\n}\n```\n", "tutorials": ["https://www.learn-cpp.org/", "https://www.cprogramming.com/tutorial/c++-tutorial.html", "http://www.cs.ecu.edu/~karl/3510/notes1.html"]}, {"name": "C", "summary": "Old, very simple language to write fast programs", "keyFeatures": ["**Procedural:** you must implement objects yourself, minimal support for functional programming", "**Weak types** and unchecked casts", "**Compiled** to assembly", "**Manual memory management** with less abstraction than C++ and Rust"], "benefits": ["**Simple:** **easier to learn** than C++ and Rust, doesn\u2019t produce confusing compiler errors", "**Direct:** simplicity means that there are no \u201chidden\u201d abstractions which can create bugs. Relatively straightforward translation to assembly and how computers (used to) execute code", "**Small:** The current C compiler is similar to the one from the 1990s, when computers were very old, so most C programs can be compiled and run on small processors"], "drawbacks": ["**Hard to abstract:** this makes it hard to represent complicated logic without making it confusing", "**Verbose:** not much syntax sugar, memory management logic must be written out more than other languages", "**Superseded** by C++: C++ offers all features of C, but also supports objects, templates and other abstractions"], "useCases": ["Efficient language for beginners", "Learning about memory management and how computers run code", "Processors with small compilers"], "history": "Developed in the 1970s, standardized in the 1980s, hasn't changed much since. [Source](https://www.bell-labs.com/usr/dmr/www/chist.html)", "example": "```c\n#include <iostream>\ntypedef struct {\n  int width;\n} square;\n\nint getArea(square s) { return s.width * s.width; }\n\nint main() {\n    printf(\"Square width = \");\n    int width;\n    scanf(\"%d\", &width);\n    square s = { width };\n    printf(\"Square area = %d\", getArea(s));\n    return 0;\n}\n```\n", "tutorials": ["https://www.learn-c.org/", "https://www.w3schools.in/c-tutorial/", "https://www.cprogramming.com/tutorial/c-tutorial.html"]}, {"name": "Rust", "summary": "Enables fast, complete memory management, but catches memory corruption errors while compiling", "keyFreatures": ["**Multi-paradigm:** Supports object-oriented, procedural, and functional paradigms", "**Strong types**, can\u2019t be casted", "**Compiled** to assembly", "**Manual memory management**, but the compiler practically ensures that there is no possible memory corruption"], "benefits": ["**Safe and Fast:** Allows you to store memory in an optimal way and gives other benefits of manual memory management, without the drawback of hard-to-fix memory corruption", "**Flexible:** includes macros which let you extend syntax, supports functional programming better than C and C++", "**Good package management** with [cargo](https://doc.rust-lang.org/cargo/guide/)"], "drawbacks": ["**Steep learning curve:** code must be written in a special way, following rules like [ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) and [lifetimes](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html), so the compiler can prove it\u2019s safe. This makes it hard to write code which even compiles", "**Verbose:** You must explicitly code how your program manages its memory, using structures like [`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) and [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html). Most libraries also wrap code in [`Results`](https://doc.rust-lang.org/std/result/), which let you catch and handle errors, but often you simply want to unwrap or convert them"], "useCases": ["Efficient new programs, which don\u2019t depend on C libraries", "Efficient secure programs"], "history": "Rust started being developed in 2006, specifically to provide the efficiency of C / C++ without memory corruption errors. [Source](https://www.infoq.com/news/2012/08/Interview-Rust)", "example": "```rust\nuse std::io;\n\ntrait Shape {\n  fn get_area(&self) -> u32;\n}\n\nstruct Square { width: u32 }\n\nimpl Shape for Square {\n  fn get_area(&self) -> u32 { return self.width * self.width; }\n}\n\nfn main() {\n  print!(\"Square width = \");\n  let mut input_text = String::new();\n  io::stdin().read_line(&mut input_text).unwrap();\n  let square = Square {\n    width: input_text.trim().parse::<u32>().unwrap(),\n  };\n  println!(\"Square area = {}\", square.get_area());\n}\n```\n", "tutorials": ["https://doc.rust-lang.org/rust-by-example/", "https://doc.rust-lang.org/book/index.html", "https://stevedonovan.github.io/rust-gentle-intro/"]}], "other": [{"name": "Other", "summary": "Don't fit into other categories, often unique and interesting", "benefits": ["Usually more **interesting** than typical languages", "**Teach** concepts which can be applied to typical languages"], "drawbacks": ["Less **online support and resources** than typical languages, since less developers use them", "Often **harder to setup and debug**"], "useCases": ["See individual languages, most have their own very specific use cases", "Learning / research", "Creative side projects"]}, {"name": "Haskell", "summary": "A very unique language which is functional, pure, and lazy.", "keyFeatures": ["**Lazy:** doesn\u2019t evaluate expressions \"step by step\", instead waits until they\u2019re needed", "**Pure:** can't modify values, e.g. if `x = 1` at one point in the code, `x` can't be set to `2` later", "Functional", "**Strong types**, supports complicated types such as [higher kinded types](https://gist.github.com/CMCDragonkai/a5638f50c87d49f815b8) and (to an extend) [dependent types](https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell), uses the [Hindley-Milner](http://dev.stephendiehl.com/fun/006_hindley_milner.html) type-system", "**Compiled** to assembly, heavily optimized", "**Garbage collected**"], "benefits": ["**Concise:** often requires much less code than other languages", "**Safe:** because of strong type checking, most bugs are caught while compiling, so *once your code runs*, it takes much less time to debug", "**Educational and interesting:** teaches unique programming concepts which can be applied to other languages", "**Fast**, especially for a functional language, because of optimizations and lazy semantics"], "drawbacks": ["**Unpopular:** not used by many companies, hard to get a Haskell job. [Statistic](https://www.tiobe.com/tiobe-index/)", "**Steep learning curve** because it\u2019s so much different than other languages", "**Hard to debug:** lazy semantics make evaluation very confusing, and because there isn\u2019t any state, it\u2019s hard to print expressions. [More info on debugging](https://wiki.haskell.org/Debugging)", "**Hard to represent state:** because it's pure and lazy, not ideal for programs like video games or simulations, which model a sequence of actions and mutation"], "useCases": ["Compilers", "Calculators", "Programs which \u201cread an input and produce an output\u201d"], "history": "Developed in 1982, has an official, formal specification written in 2010.", "example": "```hs\nimport System.IO\n\ndata Square = Square Int\n\ngetArea :: Square -> Int\ngetArea (Square width) = width * width\n\nmain :: IO ()\nmain = do\n  putStr \"Square width = \"\n  square <- Square . read <$> readLine\n  putStr \"Square area = \"\n  print $ getArea square\n```\n", "tutorials": ["https://www.haskell.org/", "http://learnyouahaskell.com/", "https://www.tutorialspoint.com/haskell/haskell_overview.htm"]}, {"name": "Scheme", "summary": "Incredibly simple language, dialect of LISP, used in research and education but rarely in production", "keyFeatures": ["**No specific paradigm (multi-paradigm)** - can write functional, procedural, object-oriented, even atypical paradigms like [logical](https://www.computerhope.com/jargon/l/logic-programming.htm).", "Usually **weak types**, but some dialects have strong types [e.g. (Racket](https://racket-lang.org/))", "Some dialects interpreted [e.g. (TinyScheme)[http://tinyscheme.sourceforge.net/home.html]), others compiled (e.g. (Chez Scheme](https://cisco.github.io/ChezScheme/))", "**Garbage collected**"], "benefits": ["**Extensible:** macros can change almost all semantics (almost everything but syntax)", "**Simple:** Very easy to understand and write an interpreter for"], "drawbacks": ["**Unpopular:** Practically impossible to find a non-research job", "Most dialects **not usable in practice**, some don't support visual output or I/O, an exception is [Racket](https://racket-lang.org/)", "**Slow:** even when compiled, slower than languages like C"], "useCases": ["Teaching / learning", "Good first language to write a compiler for"], "history": "A very old language developed in the 1970s, there are many different versions. [Source](https://web.archive.org/web/20060615225746/http://www.brics.dk/~hosc/local/HOSC-11-4-pp399-404.pdf)", "example": "Works in most dialects, including [MIT Scheme]()\n```scm\n(define (area-of-square square)\n  (let ([width (cadr square)]))\n    (* width width)))\n\n(display \"Square width = \")\n(define input (read))\n(display \"Square area = \")\n(print (area-of-square `(square ,(input))))\n```\n", "tutorials": ["https://groups.csail.mit.edu/mac/projects/scheme/", "https://schemers.org/", "http://www.shido.info/lisp/idx_scm_e.html"]}]}
