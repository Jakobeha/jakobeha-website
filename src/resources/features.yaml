language:
- name: C++
  type: Language
  summary: A powerful but complicated language. Designed to be fast but enable abstraction.
  keyFeatures:
  - 'Manual memory management'
  - 'Weak types, unchecked at runtime'
  - 'Compiled to assembly'
  - 'Object-oriented but supports first class functions'
  benefits:
  - 'Very **expressive** - can write code with almost any paradigm (object-oriented, functional, etc.)'
  - 'One of the **fastest** and **most memory-efficient** languages - as fast as C'
  - 'Used by a lot of **companies** (TODO statistic)'
  drawbacks:
  - 'Because it’s so flexible, **very hard** to write clear code - requires experience and a strict style guide'
  - '**Verbose**'
  - '**Confusing compiler errors**, especially with templates'
  - '**Unsafe** - memory corruption errors are hard to find and can be exploited'
  - '**Weak package management** - hard to compile and add libraries'
  useCases:
  - 'Embedded systems'
  - 'Bytecode interpreters'
  - 'Other programs which need to be fast and memory-efficient'
  background: Released in ..., but is constantly extended with new features even today. The C language extended with classes and powerful templates.
  examples: []
- name: JavaScript
  summary: Practically the only language to put dynamic content (e.g. animations) on websites. Also can create desktop apps via node.js.
  keyFeatures:
  - 'Garbage collected'
  - 'No types at compile-time, minimal at runtime'
  - 'Interpreted'
  - '“Ad-hoc” object-oriented but supports first class functions'
  - '*Many different languages (PureScript, Scala.js, TypeScript) which “transpile” into it* - often you can use these languages instead where you would need JavaScript*'
  benefits:
  - '**Expressive** - even supports extending builtin types'
  - '**Widely supported** - online, so computers, phones, and even consoles use it. Can also create [desktop] and [mobile] applications'
  - '**Many resources** - libraries and knowledge'
  - '**Integrated namespaces and package management** (npm) when using node.js'
  drawbacks:
  - '**Hard to find bugs** - almost no runtime errors (and definitely no compile-time errors)'
  - '**Strange semantics** - causes weird edge cases, e.g. `{} + [] == ` but `[] + {} == `'
  - '**Slow** because it’s interpreted'
  - '**Ad-hoc namespaces and no package management** when not using node.js'
  useCases:
  - 'Websites'
  - 'Cross-platform applications'
  - 'Extensions for applications developed in JavaScript (e.g. Visual Studio Code)'
  background: Originally designed to be a Scheme-like language, syntax was changed and name became JavaScript shortly before release to increase popularity.
  examples: []
- name: Java
  summary: Currently the most widely-used language, general-purpose
  keyFeatures:
  - 'Object-oriented, minimal lambda support'
  - 'Weak types, checked at runtime'
  - 'Compiled to JVM bytecode'
  - 'Garbage collected'
  benefits:
  - '**Widely used** - likely to find a job'
  - '**Encourages good design** for beginners, e.g. all code must be implemented in classes, every class'
  - '**Safe** - Runtime type checking and garbage collection makes most errors easy to find'
  drawbacks:
  - '**Verbose**'
  - '**Strict standards** - e.g. all code must be implemented in classes'
  - '**Hard to implement** functional programming, especially in earlier versions'
  - '**Slow**'
  useCases:
  - 'Teaching / learning to code'
  - 'General programs'
  - 'Embedded systems which don’t need to be particularly fast'
  background: Developed by Oracle in ... for embedded systems.
  examples: []
- name: Haskell
  summary: The most popular purely functional programming language, much different than *traditional* languages
  keyFeatures:
  - '**Lazy** - doesn’t evaluate expressions in sequence, waits until they’re needed'
  - 'Purely functional'
  - 'Strong types, higher kinds, minimal dependent types (Hindley-Milner)'
  - 'Compiled to assembly, heavily optimized'
  - 'Garbage collected'
  benefits:
  - '**Concise:** Haskell often requires much less code to perform the same actions as other languages'
  - '**Fast**, especially for a functional language, because of optimizations and lazy semantics'
  - '**Safe:** because of strong type checking, Haskell code often takes much less time to debug *after compiling*'
  - '**Teaches** unique programming concepts'
  drawbacks:
  - '**Hard to represent state:** programs which need a sequence of actions, like video games or simulations, require “monads” and confusing syntax, and they can actually be more verbose than in other languages. Most Haskell programs are simple-command line - there are relatively few programs with GUIs, and even fewer video games'
  - '**Steep learning curve** because it’s so much different than other languages'
  - '**Hard to debug:** Lazy semantics make evaluation very confusing, and because there isn’t any state, it’s hard to print expressions'
  - 'Not used by many **companies**, hard to get a Haskell job'
  useCases:
  - 'Teaching / learning to code'
  - 'Compilers'
  - 'Calculators'
  - 'Programs which “read an input and produce an output”'
  background: ...
  examples: []
- name: Scheme
  summary: Incredibly simple language used in research and education but rarely in production
  keyFeatures:
  - '**Extensible** - can change its semantics via macros'
  - 'Functional with state, supports “bare-bones” object-oriented programming'
  - 'Weak types, minimally checked at runtime (unless you provide checks)'
  - 'Garbage collected'
  benefits:
  - '**Simple:** Very easy to understand and write an interpreter for'
  - '**Extensible:** Macros allow you to almost completely modify the semantics'
  drawbacks:
  - 'Most dialects **not usable in practice** - they have limited built-in support, some can’t even do I/O or display a GUI'
  - '**Slow** - typically it’s interpreted, but even when compiled, slower than languages like C'
  useCases:
  - 'Teaching / learning'
  background: Developed in ...
  examples: []
paradigm:
- name: Object-Oriented
  summary: Represents all concepts as “objects”, and the actions they perform as “methods”. These objects are typically mutable
  keyFeatures: []
  benefits:
  - 'Most people understand this paradigm'
  - '**Intuitive:** teaches and represents structure very well, humans think of concepts and actions similarly to “objects” and “methods”'
  drawbacks:
  - '**Verbose** - objects are often very large, and an object often requires more code than an equivalent structure'
  - 'Hard to **keep track of state** - because objects are mutable, they can change at unexpected times and break assumptions, leading to bugs'
  - 'Not all functions “belong” to an object. For example, `add(a, b)` is much clearer than `a.add(b)` or `b.add(a)`'
  useCases:
  - 'Programs which model the real world (e.g. video games)'
  background: TODO ...
  examples: []
library: []
ide: []
